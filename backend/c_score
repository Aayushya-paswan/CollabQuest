from sentence_transformers import SentenceTransformer, util

# Load AI model
model = SentenceTransformer("all-MiniLM-L6-v2")


def semantic_compatibility_pairwise(skills_a, skills_b, threshold=0.2):
    """
    Per-skill semantic matching.
    - Each skill is encoded separately.
    - For each skill, we take its best match from the other person.
    - Similarities below threshold are ignored (treated as 0).
    - Similarities above threshold are boosted with sqrt to feel more natural.
    Returns score in 0â€“100.
    """

    if not skills_a or not skills_b:
        return 0.0

    # Encode each skill separately
    emb_a = model.encode(skills_a, convert_to_tensor=True)
    emb_b = model.encode(skills_b, convert_to_tensor=True)

    # Similarity matrix: len(A) x len(B)
    sim_matrix = util.cos_sim(emb_a, emb_b)

    # For each skill in A, best match in B
    a_to_b_max = sim_matrix.max(dim=1).values  # shape: (len(A),)
    # For each skill in B, best match in A
    b_to_a_max = sim_matrix.max(dim=0).values  # shape: (len(B),)

    def score_from_vector(vec):
        # vec is 1D tensor of similarities
        mask = vec >= threshold
        if mask.sum().item() == 0:
            return 0.0

        # Keep only decent matches
        filtered = vec[mask]

        # Boost mid values: e.g. 0.4 -> 0.63, 0.5 -> 0.70, 0.7 -> 0.84
        boosted = filtered.sqrt()

        return float(boosted.mean().item())

    score_a_to_b = score_from_vector(a_to_b_max)
    score_b_to_a = score_from_vector(b_to_a_max)

    final_score = (score_a_to_b + score_b_to_a) / 2.0

    return round(final_score * 100, 2)


if __name__ == "__main__":
    tests = [
    # 1. Exact / near-exact matches
    (["python"], ["python"]),
    (["python"], ["Python", "coding"]),
    (["python", "Django", "css"], ["python", "Django", "css"]),
    (["html", "css"], ["css", "html"]),
    (["machine learning"], ["ml"]),
    (["artificial intelligence"], ["ai"]),
    
    # 2. Same domain, slightly different wording
    (["web development"], ["html"]),
    (["web development"], ["html", "css", "javascript"]),
    (["frontend"], ["react", "css", "javascript"]),
    (["backend"], ["django", "databases"]),
    (["backend"], ["coding", "python"]),
    (["data science"], ["python", "pandas", "statistics"]),
    (["android development"], ["kotlin", "mobile apps"]),
    
    # 3. Tech vs generic "coding/dev" type words
    (["python"], ["coding"]),
    (["java"], ["coding", "oop"]),
    (["web development"], ["coding", "designing"]),
    (["backend"], ["development", "coding"]),
    
    # 4. Extra noisy non-tech skills added
    (["python"], ["coding", "python", "cooking"]),
    (["web development"], ["html", "css", "singing"]),
    (["machine learning"], ["ai", "dancing", "public speaking"]),
    (["data science"], ["excel", "storytelling", "guitar"]),
    (["react"], ["javascript", "music", "fitness"]),
    
    # 5. Completely unrelated skills
    (["web development"], ["cooking"]),
    (["python"], ["painting"]),
    (["machine learning"], ["singing"]),
    (["backend"], ["cooking", "traveling"]),
    (["data science"], ["yoga", "baking"]),
    
    # 6. Partially overlapping tech stacks
    (["python", "django"], ["python", "flask"]),
    (["react", "javascript"], ["vue", "javascript"]),
    (["html", "css", "javascript"], ["html", "css", "figma"]),
    (["ml", "deep learning"], ["machine learning", "pytorch"]),
    (["devops"], ["docker", "ci/cd", "linux"]),
    
    # 7. One very broad, one specific
    (["full stack"], ["react", "nodejs", "mongodb"]),
    (["web development"], ["react"]),
    (["data"], ["data science", "sql"]),
    (["programming"], ["python"]),
    
    # 8. Multi-word vs single-word
    (["full stack developer"], ["react", "nodejs", "database"]),
    (["mobile app development"], ["android", "flutter"]),
    (["database management"], ["sql"]),
    
    # 9. Mixed tech + hobbies on both sides
    (["python", "web development", "football"], ["html", "css", "python", "cricket"]),
    (["machine learning", "music"], ["ai", "piano"]),
    (["game development", "c++"], ["unity", "c#"]),
    
    # 10. Edge-ish cases
    (["coding"], ["coding"]),
    (["dev"], ["developer"]),
    (["javascript"], ["js"]),
    (["ui ux"], ["design", "figma"]),
    (["dsa"], ["algorithms", "data structures"]),
]

    for a, b in tests:
        score = semantic_compatibility_pairwise(a, b)
        print(f"Skills A: {a}")
        print(f"Skills B: {b}")
        print("Compatibility Score:", score, "%")
        print("-" * 40)

